package langd

import (
	"fmt"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"

	"github.com/object88/langd/collections"
	"github.com/object88/langd/log"
)

// Loader scans a set of directories for Go files and creates an AST of the
// program.
type Loader struct {
	config  *types.Config
	srcDirs []string
	stderr  *log.Log

	fset        *token.FileSet
	importGraph *collections.Caravan

	dirQueue *collections.InfiniteQueue

	directories map[string]*Directory
	m           sync.Mutex

	done chan bool
}

// NewLoader constructs a new Loader struct
func NewLoader() *Loader {
	l := log.Stderr()
	l.SetLevel(log.Verbose)
	config := &types.Config{
		Error: func(e error) {
			l.Warnf("%s\n", e.Error())
		},
		Importer: importer.Default(),
	}

	srcDirs := build.Default.SrcDirs()

	return &Loader{
		config:      config,
		srcDirs:     srcDirs,
		stderr:      l,
		fset:        token.NewFileSet(),
		importGraph: collections.CreateCaravan(),
		dirQueue:    collections.CreateInfiniteQueue(),
		directories: map[string]*Directory{},
		done:        make(chan bool),
	}
}

// LoadDirectories reads in the file of the given directories.  LoadDirectories
// will not read directories that begin with a "." (i.e., ".git"), and it will
// not follow symbolic links.
func (l *Loader) LoadDirectories(paths ...string) error {
	for _, dpath := range paths {
		l.loadDirectory(dpath)
	}
	return nil
}

// Start initializes the dispatcher for file and directory load events.  The
// dispatch is stopped by passing a bool (any value) into the returned
// channel.
func (l *Loader) Start(base string) (<-chan bool, error) {
	abs, err := validateInitialPath(base)
	if err != nil {
		return nil, err
	}

	pkgName := ""
	for _, v := range l.srcDirs {
		if strings.HasPrefix(abs, v) {
			pkgName = abs[len(v)+1:]
		}
	}
	if pkgName == "" {
		return nil, fmt.Errorf("Failed to find '%s'", base)
	}

	done := make(chan bool)
	importsDone := make(chan bool)

	go func() {
		for {
			select {
			case _, ok := <-l.done:
				if !ok {
					return
				}

			case pimportDir := <-l.dirQueue.Out():
				imp := pimportDir.(*importDir)
				go l.processDir(imp)

			case <-importsDone:
				fmt.Printf("*** Reported imports done...\n")
				ready := true

				l.importGraph.Walk(collections.WalkDown, func(k collections.Keyer, _, _ bool) {
					if k.(*Package).astPkg == nil {
						ready = false
					}
				})
				if ready {
					fmt.Printf("*** *** Completely done\n")
					done <- true
				}
			}
		}
	}()

	return done, nil
}

// Close will stop monitoring the files
func (l *Loader) Close() {
	close(l.done)
}

func (l *Loader) loadDirectory(dpath string) error {
	prefix := ""
	for _, v := range l.srcDirs {
		if strings.HasPrefix(dpath, v) {
			prefix = dpath[len(v)+1:]
		}
	}
	if prefix == "" {
		return fmt.Errorf("%s is not in gopath or goroot", dpath)
	}

	filepath.Walk(dpath, func(dpath string, info os.FileInfo, _ error) error {
		if !info.IsDir() {
			return nil
		}

		// Skipping directories that start with "." (i.e., .git)
		if strings.HasPrefix(filepath.Base(info.Name()), ".") {
			return filepath.SkipDir
		}

		// dpath: /Users/bropa18/work/src/github.com/object88/langd/examples/echo
		l.dirQueue.In() <- &importDir{
			path: dpath,
		}

		return nil
	})

	return nil
}

func (l *Loader) processDir(imp *importDir) {
	l.m.Lock()

	absPath := findPackagePath(".", imp.path)

	if _, ok := l.directories[absPath]; ok {
		// s, _ := l.importGraph.Find(imp.src.Key())
		// d, _ := l.importGraph.Find(buildKey(imp.imp, imp.path))
		// l.importGraph.Connect(s, d)
		l.m.Unlock()
		return
	}

	d := CreateDirectory(absPath)
	l.directories[absPath] = d

	// if imp.src != nil {
	// 	s, _ := l.importGraph.Find(imp.source.Key())
	// 	d, _ := l.importGraph.Find(imp.dest.Key())
	// 	l.importGraph.Connect(s, d)
	// }

	l.m.Unlock()

	// go d.Scan(l.fset, l.importGraph, l.dirQueue.In())
	buildPkg, err := build.ImportDir(d.path, 0)
	if err != nil {
		if _, ok := err.(*build.NoGoError); ok {
			// There isn't any Go code here.
			fmt.Printf("NO GO CODE: %s\n", d.path)
			return
		}
		fmt.Printf("Oh dear:\n\t%s\n\t%s\n", d.path, err.Error())
	}
	d.buildPkg = buildPkg

	var wg sync.WaitGroup
	imports := importMap{}

	count := len(buildPkg.GoFiles) + len(buildPkg.TestGoFiles)
	wg.Add(count)

	for _, v := range buildPkg.GoFiles {
		fpath := filepath.Join(buildPkg.Dir, v)
		go l.processFile(imports, d, fpath, &wg)
	}

	for _, v := range buildPkg.TestGoFiles {
		fpath := filepath.Join(buildPkg.Dir, v)
		go l.processFile(imports, d, fpath, &wg)
	}

	wg.Wait()

	fmt.Printf("Scanned %s\n", d.path)

	// Take all the imports, and announce them back for processing
	for src, imps := range imports {
		for imp := range imps {
			absPath := findPackagePath(imp, buildPkg.ImportPath)
			l.dirQueue.In() <- &importDir{
				imp:  imp,
				path: absPath,
				src:  src,
			}
		}
	}
}

func (l *Loader) processFile(imports importMap, d *Directory, fpath string, wg *sync.WaitGroup) {
	astf, err := parser.ParseFile(l.fset, fpath, nil, 0)
	if err != nil {
		fmt.Printf("Got error while parsing file '%s':\n\t%s\n", fpath, err.Error())
		// l.ls.errs = append(l.ls.errs, err)
		wg.Done()
		return
	}

	absPath := filepath.Dir(fpath)
	pkgName := astf.Name.Name

	d.m.Lock()

	var pkg *Package
	for _, v := range d.pkgs {
		if v.path == absPath && v.pkgName == pkgName {
			pkg = v
			break
		}
	}
	if pkg == nil {
		pkg = &Package{
			astPkg: &ast.Package{
				Name:  pkgName,
				Files: map[string]*ast.File{},
			},
			path:    absPath,
			pkgName: pkgName,
		}
		l.importGraph.Insert(pkg)
		d.pkgs = append(d.pkgs, pkg)
	}

	src := &importKey{
		pkgName: pkgName,
		absPath: absPath,
	}

	for _, decl := range astf.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok || decl.Tok != token.IMPORT {
			continue
		}

		for _, spec := range decl.Specs {
			spec := spec.(*ast.ImportSpec)

			// NB: do not assume the program is well-formed!
			path, err := strconv.Unquote(spec.Path.Value)
			if err != nil || path == "C" {
				// Ignore the error and skip the C psuedo package
				continue
			}
			destMap, ok := imports[src]
			if !ok {
				destMap = map[string]bool{}
				imports[src] = destMap
			}
			destMap[path] = true
		}
	}

	d.m.Unlock()

	wg.Done()
}

//////////
// Scratch code

type importKey struct {
	pkgName string
	absPath string
}

func (ik *importKey) Key() collections.Key {
	k := fmt.Sprintf("%s:%s", ik.pkgName, ik.absPath)
	return collections.Key(k)
}

type importDir struct {
	imp  string
	path string
	src  *importKey
}

func findPackagePath(path, src string) string {
	buildPkg, err := build.Import(path, src, build.FindOnly)
	if err != nil {
		fmt.Printf("Oh dear:\n\t%s\n", err.Error())
	}
	if buildPkg.Dir == "" {
		// If Dir is the empty string, this is a stdlib package?
		return path
	}
	return buildPkg.Dir
}

func validateInitialPath(p string) (string, error) {
	abs, err := filepath.Abs(p)
	if err != nil {
		return "", err
	}

	fi, err := os.Stat(abs)
	if err != nil {
		return "", err
	}
	if !fi.IsDir() {
		return "", fmt.Errorf("Provided path '%s' must be a directory", p)
	}

	return abs, nil
}
